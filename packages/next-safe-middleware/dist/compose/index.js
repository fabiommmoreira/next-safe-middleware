'use strict';Object.defineProperty(exports,'__esModule',{value:true});var server=require('next/server');const memoizeInChainCache=(key,f)=>ctx=>async(...args)=>{const cached=ctx.cache.get(key);if(cached){return cached}const fetched=await f(ctx,...args);ctx.cache.set(key,fetched);return fetched};const globalCache={};const memoizeInGlobalCache=(key,f)=>async(...args)=>{const cached=globalCache[key];if(cached){return cached}const fetched=await f(...args);globalCache[key]=fetched;return fetched};const memoizeResponseHeader=(header,fromHeaderValue,toHeaderValue,merger)=>{const writeHeaderCallback=(req,evt,ctx)=>{const cached=ctx.cache.get(header);if(cached){const resHeaders=ctx.res.get().headers;const headerValue=toHeaderValue(cached);if(headerValue){resHeaders.set(header,headerValue)}}};return ctx=>{ctx.finalize.addCallback(writeHeaderCallback);const fromCacheOrRes=()=>{const fromCache=ctx.cache.get(header);if(fromCache){return fromCache}const resHeaders=ctx.res.get().headers;const value=resHeaders.get(header)||"";return fromHeaderValue(value)};const set=value=>{const fromCache=ctx.cache.get(header);if(!fromCache||!merger){ctx.cache.set(header,value);return}ctx.cache.set(header,merger(fromCache,value))};const value1=fromCacheOrRes();return[value1,set]}};const matchNot=matcher=>req=>!matcher(req);const matchAnd=(...matchers)=>req=>{let matches=true;for(const matcher of matchers){matches=matcher(req);if(!matches)return matches}return matches};const matchOr=(...matchers)=>req=>{let matches=false;for(const matcher of matchers){matches=matcher(req);if(matches)return matches}return matches};const isPagePathRequest=req=>{const isNonPagePathPrefix=/^\/(?:_next|api)\//;const isFile=/\..*$/;const{pathname}=req.nextUrl;return!isNonPagePathPrefix.test(pathname)&&!isFile.test(pathname)};const isPreviewModeRequest=req=>!!req.cookies.get("__next_preview_data");const isNextJsDataRequest=req=>!!req.headers.get("x-nextjs-data");const isPageRequest=matchAnd(isPagePathRequest,matchNot(isPreviewModeRequest),matchNot(isNextJsDataRequest));const deepFreeze=obj=>{Object.keys(obj).forEach(prop=>{if(typeof obj[prop]==="object")deepFreeze(obj[prop])});return Object.freeze(obj)};const chain=(...middlewares)=>async(req,evt)=>{let chainResponse;const cache={};const finalizers=[];const ctx=deepFreeze({res:{get:()=>{if(!chainResponse){chainResponse=server.NextResponse.next()}return chainResponse},set:res=>chainResponse=res},cache:{get:k=>cache[k],set:(k,v)=>cache[k]=v},finalize:{addCallback:f=>{if(!finalizers.includes(f)){finalizers.push(f)}}}});const finalize1=async()=>{try{return Promise.all(finalizers.map(finalize=>finalize(req,evt,ctx)))}catch(error){console.error("[chain]: finalization error",{error})}};for await(const middleware of middlewares){const mwRes=await middleware(req,evt,ctx);if(mwRes){return mwRes}}await finalize1();return chainResponse};const chainMatch=matcher=>(...middlewares)=>async(req,evt)=>{if(matcher(req)){return chain(...middlewares)(req,evt)}};const chainableMiddleware=middleware=>{return async(req,evt,ctx)=>{if(ctx){return middleware(req,evt,ctx)}return chain(middleware)(req,evt)}};const continued=nextMiddleware=>chainableMiddleware(async(req,evt,ctx)=>{const mwRes=await nextMiddleware(req,evt);if(mwRes){ctx.res.set(mwRes)}});exports.chain=chain;exports.chainMatch=chainMatch;exports.chainableMiddleware=chainableMiddleware;exports.continued=continued;exports.isNextJsDataRequest=isNextJsDataRequest;exports.isPagePathRequest=isPagePathRequest;exports.isPageRequest=isPageRequest;exports.isPreviewModeRequest=isPreviewModeRequest;exports.matchAnd=matchAnd;exports.matchNot=matchNot;exports.matchOr=matchOr;exports.memoizeInChainCache=memoizeInChainCache;exports.memoizeInGlobalCache=memoizeInGlobalCache;exports.memoizeResponseHeader=memoizeResponseHeader
